<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Анализатор контактов LinkedIn v3</title>
    <style>
        :root {
            --primary-color: #0077b5; /* LinkedIn Blue */
            --light-gray: #f8f9fa;
            --medium-gray: #e9ecef;
            --dark-gray: #6c757d;
            --text-color: #343a40;
            --white: #ffffff;
            --border-color: #dee2e6;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.05);
            --shadow-md: 0 4px 8px rgba(0,0,0,0.07);
            --border-radius: 6px;
            --highlight-color: #ffff99;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            line-height: 1.6;
            margin: 0;
            background-color: var(--light-gray);
            color: var(--text-color);
            font-size: 16px;
        }

        .container {
            max-width: 1300px;
            margin: 30px auto;
            background-color: var(--white);
            padding: 25px 40px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-md);
        }

        h1 {
            color: #1a1a1a;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
            margin-bottom: 25px;
            font-size: 1.8em;
            font-weight: 600;
        }
        h2 {
            font-size: 1.5em;
            margin-top: 45px;
            margin-bottom: 15px;
            color: #2a2a2a;
            font-weight: 600;
            border-bottom: 1px solid var(--medium-gray);
            padding-bottom: 5px;
        }

        /* --- Input Controls --- */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 30px;
            padding: 15px;
            background-color: var(--light-gray);
            border-radius: var(--border-radius);
        }
        .control-group {
            flex: 1 1 300px; /* Grow, shrink, basis */
        }
        .control-group label {
            display: block;
            font-weight: 500;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: var(--dark-gray);
        }
        input[type="file"], input[type="search"] {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 1em;
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
        }
        input[type="file"] {
             background-color: var(--white);
        }

        #loadingIndicator {
            display: none;
            font-style: italic;
            color: var(--dark-gray);
            margin: 15px 0 0 5px; /* Adjusted margin */
            width: 100%; /* Take full width in flex */
        }

        /* --- Navigation --- */
        #nav-container {
            margin-bottom: 30px;
            padding: 10px 0;
            border-bottom: 1px solid var(--medium-gray);
        }
        #nav-container a {
            display: inline-block;
            margin-right: 12px;
            margin-bottom: 8px;
            padding: 6px 12px;
            background-color: var(--medium-gray);
            color: var(--text-color);
            border-radius: var(--border-radius);
            font-size: 0.9em;
            font-weight: 500;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        #nav-container a:hover {
            background-color: var(--primary-color);
            color: var(--white);
            text-decoration: none;
        }

        /* --- Tabs --- */
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            font-weight: 500;
            color: var(--dark-gray);
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            margin-right: 5px;
        }
        .tab.active {
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
        }
        .tab:hover:not(.active) {
            border-bottom: 2px solid var(--medium-gray);
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* --- Table Styling --- */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 25px;
            font-size: 0.85em; /* Smaller font for more compact tables */
            background-color: var(--white);
            box-shadow: var(--shadow-sm);
            table-layout: fixed;
            border: 1px solid var(--border-color); /* Add border around table */
            border-radius: var(--border-radius); /* Apply radius */
            overflow: hidden; /* Clip content to border-radius */
        }
        th, td {
            border: none; /* Remove internal borders */
            border-bottom: 1px solid var(--border-color); /* Use bottom border for separation */
            padding: 8px 10px; /* Reduced padding for compact view */
            text-align: left;
            vertical-align: top;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        thead tr { /* Give header a distinct background */
             background-color: #f2f5f8; /* Slightly different light blue-gray */
        }
        th {
            background-color: transparent; /* Remove default th background */
            cursor: pointer;
            position: relative;
            font-weight: 600;
            color: #495057;
            border-bottom-width: 2px; /* Make header border thicker */
            border-color: var(--medium-gray);
        }
        th::after {
            content: ' \2195';
            opacity: 0.3;
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.8em;
            color: var(--dark-gray);
        }
        th.sorted-asc::after {
            content: ' \2191';
            opacity: 1;
            color: var(--primary-color);
        }
        th.sorted-desc::after {
            content: ' \2193';
            opacity: 1;
            color: var(--primary-color);
        }
        tbody tr:last-child td {
            border-bottom: none; /* Remove border from last row */
        }
        tbody tr:hover {
            background-color: #f1f8ff; /* Light blue hover */
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
        }
        a:hover {
            text-decoration: underline;
        }
        .profile-cell span { /* Styling for email */
            display: block;
            font-size: 0.9em;
            color: var(--dark-gray);
            margin-top: 4px;
        }

        /* Highlighted search terms */
        .highlight {
            background-color: var(--highlight-color);
            padding: 0 2px;
            border-radius: 2px;
        }

        /* Column widths */
        .col-name { width: 18%; }
        .col-company { width: 25%; }
        .col-position { width: 32%; }
        .col-profile { width: 25%; }

        /* Hide rows smoothly */
        tbody tr.hidden-row {
            display: none;
        }

        /* Advanced search panel */
        .search-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        .search-field {
            flex: 1 1 200px;
        }
        .search-field input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
        }

        /* Analytics styles */
        #analyticsContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .chart-container {
            flex: 1 1 400px;
            background: var(--white);
            padding: 15px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
            margin-bottom: 20px;
        }

        /* Visualization styles */
        #networkContainer {
            width: 100%;
            height: 600px;
            background: var(--white);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 15px 20px;
                margin: 15px;
            }
            .controls {
                flex-direction: column;
            }
            h1 { font-size: 1.5em; }
            h2 { font-size: 1.3em; }
            th, td { padding: 6px 8px; font-size: 0.8em; }
             /* Consider hiding less important columns or allowing horizontal scroll on small screens */
             table { display: block; overflow-x: auto; white-space: nowrap; }
        }

    </style>
</head>
<body>

    <div class="container">
        <h1>Анализатор контактов LinkedIn</h1>
        <p>Загрузите ваш CSV файл (<code>Connections.csv</code>) для анализа сети контактов.</p>

        <div class="controls">
            <div class="control-group">
                <label for="fileInput">1. Выберите CSV файл:</label>
                <input type="file" id="fileInput" accept=".csv">
            </div>
            <div id="loadingIndicator">Обработка файла...</div>
        </div>

        <!-- Tabs Navigation -->
        <div class="tabs">
            <button class="tab active" data-tab="contacts">Контакты</button>
            <button class="tab" data-tab="analytics">Аналитика</button>
            <button class="tab" data-tab="network">Визуализация Сети</button>
        </div>

        <!-- Contacts Tab -->
        <div id="contacts-tab" class="tab-content active">
            <div class="search-panel">
                <div class="search-field">
                    <label for="nameSearch">Имя:</label>
                    <input type="search" id="nameSearch" placeholder="Поиск по имени...">
                </div>
                <div class="search-field">
                    <label for="companySearch">Компания:</label>
                    <input type="search" id="companySearch" placeholder="Поиск по компании...">
                </div>
                <div class="search-field">
                    <label for="positionSearch">Должность:</label>
                    <input type="search" id="positionSearch" placeholder="Поиск по должности...">
                </div>
            </div>

            <div id="nav-container">
                <!-- Навигация будет вставлена сюда -->
            </div>

            <div id="contacts-container">
                <!-- Результаты будут отображены здесь -->
            </div>
        </div>

        <!-- Analytics Tab -->
        <div id="analytics-tab" class="tab-content">
            <h2>Аналитика контактов</h2>
            <div id="analyticsContainer">
                <div class="chart-container">
                    <h3>Распределение по категориям</h3>
                    <canvas id="categoriesChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3>Топ компаний</h3>
                    <canvas id="companiesChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Network Visualization Tab -->
        <div id="network-tab" class="tab-content">
            <h2>Визуализация сети контактов</h2>
            <div id="networkContainer">
                <!-- Визуализация сети будет здесь -->
            </div>
        </div>
    </div>

    <!-- Подключаем необходимые библиотеки -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vis-network@9.1.2/dist/vis-network.min.js"></script>

    <script>
        const fileInput = document.getElementById('fileInput');
        const nameSearch = document.getElementById('nameSearch');
        const companySearch = document.getElementById('companySearch');
        const positionSearch = document.getElementById('positionSearch');
        const container = document.getElementById('contacts-container');
        const navContainer = document.getElementById('nav-container');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        
        let allContactsData = []; // Store parsed data globally for filtering
        let charts = {}; // Store chart instances
        let network = null; // Network visualization

        // Tab functionality
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.getAttribute('data-tab');
                
                // Update active tab
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Show active content
                tabContents.forEach(content => {
                    content.classList.remove('active');
                    if (content.id === `${tabId}-tab`) {
                        content.classList.add('active');
                    }
                });
                
                // Render charts or network if analytics tab is activated
                if (tabId === 'analytics' && allContactsData.length > 0) {
                    renderCharts();
                } else if (tabId === 'network' && allContactsData.length > 0) {
                    renderNetwork();
                }
            });
        });

        fileInput.addEventListener('change', handleFileSelect, false);

        // Debounce function to limit filter calls on rapid input
        function debounce(func, wait) {
          let timeout;
          return function executedFunction(...args) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        };

        const debouncedFilter = debounce(filterContacts, 250); // Debounce search input by 250ms

        // Set up search inputs with debounced filtering
        nameSearch.addEventListener('input', () => debouncedFilter());
        companySearch.addEventListener('input', () => debouncedFilter());
        positionSearch.addEventListener('input', () => debouncedFilter());

        // Web Worker for parsing CSV
        let csvWorker;
        
        function initWorker() {
            // Create a blob URL for the worker script
            const workerScript = `
                self.onmessage = function(e) {
                    const csvText = e.data;
                    try {
                        const parsedData = parseCSV(csvText);
                        self.postMessage({ type: 'success', data: parsedData });
                    } catch (error) {
                        self.postMessage({ type: 'error', message: error.message });
                    }
                };
                
                function parseCsvRow(row) {
                    const result = [];
                    let currentVal = '';
                    let inQuotes = false;
                    for (let i = 0; i < row.length; i++) {
                        const char = row[i];
                        const nextChar = row[i+1];
                
                        if (char === '"' && inQuotes && nextChar === '"') {
                            currentVal += '"';
                            i++;
                        } else if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            result.push(currentVal.trim());
                            currentVal = '';
                        } else {
                            currentVal += char;
                        }
                    }
                    result.push(currentVal.trim());
                    return result;
                }
                
                function parseCSV(text) {
                    const lines = text.split('\\n');
                    const contacts = [];
                    let header = [];
                    let headerFound = false;
                    let headerLineIndex = -1;
                
                    // Find header row
                    for (let i = 0; i < Math.min(lines.length, 10); i++) {
                        const potentialHeader = parseCsvRow(lines[i]);
                        if (potentialHeader.length > 3 &&
                            potentialHeader[0]?.toLowerCase().trim() === 'first name' &&
                            potentialHeader[1]?.toLowerCase().trim() === 'last name' &&
                            potentialHeader[2]?.toLowerCase().trim() === 'url' &&
                            potentialHeader[4]?.toLowerCase().trim() === 'company' &&
                            potentialHeader[5]?.toLowerCase().trim() === 'position') {
                            header = potentialHeader.map(h => h.trim());
                            headerFound = true;
                            headerLineIndex = i;
                            break;
                        }
                    }
                
                    if (!headerFound) {
                        throw new Error("Не удалось найти строку заголовка в CSV.");
                    }
                
                    const firstNameIndex = header.findIndex(h => h.toLowerCase() === 'first name');
                    const lastNameIndex = header.findIndex(h => h.toLowerCase() === 'last name');
                    const urlIndex = header.findIndex(h => h.toLowerCase() === 'url');
                    const emailIndex = header.findIndex(h => h.toLowerCase() === 'email address');
                    const companyIndex = header.findIndex(h => h.toLowerCase() === 'company');
                    const positionIndex = header.findIndex(h => h.toLowerCase() === 'position');
                
                    // Process data rows
                    for (let i = headerLineIndex + 1; i < lines.length; i++) {
                        const line = lines[i];
                        if (line.trim() === '' || line.startsWith('"Notes:')) continue;
                
                        const values = parseCsvRow(line);
                
                        if (values.length < Math.max(firstNameIndex, lastNameIndex, urlIndex, companyIndex, positionIndex) + 1) {
                            continue;
                        }
                
                        const firstName = values[firstNameIndex] || '';
                        const lastName = values[lastNameIndex] || '';
                        const url = values[urlIndex] || '';
                        const company = values[companyIndex] || '';
                        const position = values[positionIndex] || '';
                
                        if (!firstName && !lastName && !url && !company && !position) {
                            continue;
                        }
                
                        const contact = {
                            firstName: firstName,
                            lastName: lastName,
                            url: url,
                            email: (emailIndex > -1 && values[emailIndex]) ? values[emailIndex] : '',
                            company: company || 'N/A',
                            position: position || 'N/A',
                            fullName: \`\${firstName} \${lastName}\`.trim()
                        };
                        contacts.push(contact);
                    }
                    return contacts;
                }
            `;
            
            const blob = new Blob([workerScript], { type: 'application/javascript' });
            const blobURL = URL.createObjectURL(blob);
            
            csvWorker = new Worker(blobURL);
            
            csvWorker.onmessage = function(e) {
                const { type, data, message } = e.data;
                
                if (type === 'success') {
                    allContactsData = data;
                    const categorizedContacts = categorizeContacts(allContactsData);
                    displayContacts(categorizedContacts);
                    createNavigation(categorizedContacts);
                    
                    // Initialize analytics if data is loaded
                    if (document.querySelector('.tab[data-tab="analytics"]').classList.contains('active')) {
                        renderCharts();
                    }
                    if (document.querySelector('.tab[data-tab="network"]').classList.contains('active')) {
                        renderNetwork();
                    }
                } else if (type === 'error') {
                    console.error("Worker error:", message);
                    container.innerHTML = `<p style="color: red;">Ошибка при обработке файла: ${message}</p>`;
                }
                
                loadingIndicator.style.display = 'none';
            };
            
            csvWorker.onerror = function(error) {
                console.error("Worker error:", error);
                container.innerHTML = '<p style="color: red;">Ошибка при обработке файла.</p>';
                loadingIndicator.style.display = 'none';
            };
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            loadingIndicator.style.display = 'block';
            container.innerHTML = '';
            navContainer.innerHTML = '';
            allContactsData = [];
            nameSearch.value = '';
            companySearch.value = '';
            positionSearch.value = '';
            
            // Reset charts and network
            Object.values(charts).forEach(chart => chart.destroy());
            charts = {};
            if (network) {
                network.destroy();
                network = null;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                
                // Initialize Web Worker for CSV parsing
                if (window.Worker) {
                    if (!csvWorker) {
                        initWorker();
                    }
                    csvWorker.postMessage(text);
                } else {
                    // Fallback for browsers without Worker support
                    try {
                        allContactsData = parseCSV(text);
                        const categorizedContacts = categorizeContacts(allContactsData);
                        displayContacts(categorizedContacts);
                        createNavigation(categorizedContacts);
                        loadingIndicator.style.display = 'none';
                    } catch (error) {
                        console.error("Error processing file:", error);
                        container.innerHTML = `<p style="color: red;">Ошибка при обработке файла: ${error.message}</p>`;
                        loadingIndicator.style.display = 'none';
                    }
                }
            };
            reader.onerror = function(e) {
                console.error("FileReader error:", e);
                loadingIndicator.style.display = 'none';
                container.innerHTML = '<p style="color: red;">Не удалось прочитать файл.</p>';
            }
            reader.readAsText(file, 'UTF-8');
        }

        function parseCsvRow(row) {
            const result = [];
            let currentVal = '';
            let inQuotes = false;
            for (let i = 0; i < row.length; i++) {
                const char = row[i];
                const nextChar = row[i+1];

                if (char === '"' && inQuotes && nextChar === '"') {
                    currentVal += '"';
                    i++;
                } else if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(currentVal.trim());
                    currentVal = '';
                } else {
                    currentVal += char;
                }
            }
            result.push(currentVal.trim());
            return result;
        }

        function parseCSV(text) {
            const lines = text.split('\n');
            const contacts = [];
            let header = [];
            let headerFound = false;
            let headerLineIndex = -1;

             // Find header row more reliably
             for (let i = 0; i < Math.min(lines.length, 10); i++) { // Check first 10 lines
                 const potentialHeader = parseCsvRow(lines[i]);
                 if (potentialHeader.length > 3 &&
                     potentialHeader[0]?.toLowerCase().trim() === 'first name' &&
                     potentialHeader[1]?.toLowerCase().trim() === 'last name' &&
                     potentialHeader[2]?.toLowerCase().trim() === 'url' &&
                     potentialHeader[4]?.toLowerCase().trim() === 'company' && // Added checks for other core columns
                     potentialHeader[5]?.toLowerCase().trim() === 'position') {
                     header = potentialHeader.map(h => h.trim());
                     headerFound = true;
                     headerLineIndex = i;
                     break;
                 }
             }

            if (!headerFound) {
                throw new Error("Не удалось найти строку заголовка (First Name, Last Name, URL, Company, Position, ...) в CSV.");
            }

            const firstNameIndex = header.findIndex(h => h.toLowerCase() === 'first name');
            const lastNameIndex = header.findIndex(h => h.toLowerCase() === 'last name');
            const urlIndex = header.findIndex(h => h.toLowerCase() === 'url');
            const emailIndex = header.findIndex(h => h.toLowerCase() === 'email address');
            const companyIndex = header.findIndex(h => h.toLowerCase() === 'company');
            const positionIndex = header.findIndex(h => h.toLowerCase() === 'position');

            // Start processing lines *after* the header
            for (let i = headerLineIndex + 1; i < lines.length; i++) {
                 const line = lines[i];
                if (line.trim() === '' || line.startsWith('"Notes:')) continue;

                const values = parseCsvRow(line);

                if (values.length < Math.max(firstNameIndex, lastNameIndex, urlIndex, companyIndex, positionIndex) + 1) {
                     continue; // Skip rows that don't have enough columns
                 }

                 const firstName = values[firstNameIndex] || '';
                 const lastName = values[lastNameIndex] || '';
                 const url = values[urlIndex] || '';
                 const company = values[companyIndex] || ''; // Keep empty if truly empty
                 const position = values[positionIndex] || ''; // Keep empty if truly empty

                // Skip clearly empty/placeholder rows
                if (!firstName && !lastName && !url && !company && !position) {
                    continue;
                }

                const contact = {
                    firstName: firstName,
                    lastName: lastName,
                    url: url,
                    email: (emailIndex > -1 && values[emailIndex]) ? values[emailIndex] : '',
                    company: company || 'N/A', // Display N/A if empty after filtering
                    position: position || 'N/A',
                    fullName: `${firstName} ${lastName}`.trim()
                };
                contacts.push(contact);
            }
            return contacts;
        }


        function categorizeContacts(contacts) {
             const categories = {
                'CEO / Founder / C-Level': [],
                'Investor / VC / Partner': [],
                'HR / Recruiter / Talent': [],
                'Business Development / Sales / Partnerships': [],
                'Director / VP / Head Of / Lead': [], // Combined leadership
                'Product / Design / Producer / Creative': [], // Combined creative/product roles
                'Technical / Engineering / Developer / QA / Analyst': [], // Combined tech roles
                'Marketing / Growth / UA': [],
                'Other': []
            };

            const roleMatchers = {
                'CEO / Founder / C-Level': /\b(CEO|Chief Executive Officer|Founder|Co-Founder|Owner|President|Chairman|Managing Director|CFO|Chief Financial Officer|COO|Chief Operating Officer|CTO|Chief Technology Officer|CPO|Chief Product Officer|CIO|CRO|CSO|Geschäftsführer|Fondateur)\b/i,
                'Investor / VC / Partner': /\b(Investor|Partner|VC|Venture|Capital|Investment|Principal|GP|General Partner|Angel|Fund|Managing Partner|Associate)\b/i, // Added Associate
                'HR / Recruiter / Talent': /\b(HR|Human Resources|Recruiter|Recruitment|Talent Acquisition|Head of People|People Partner|HRBP|Sourcer|Staffing|Talent Partner|Personnel)\b/i,
                'Business Development / Sales / Partnerships': /\b(Business Development|BDM|Sales|Partnerships|Account Manager|Account Executive|Commercial Director|Client Manager)\b/i,
                 'Director / VP / Head Of / Lead': /\b(Director|VP|Vice President|Head of|Lead|Manager|Supervisor|Coordinator|Руководитель|Директор)\b/i, // Made broader, includes Manager/Lead
                'Product / Design / Producer / Creative': /\b(Product|Game Designer|Designer|Producer|UX|UI|Creative|Art|Artist|Animation|Gameplay|Narrative|Writer|Photographer|Дизайнер)\b/i, // Broader creative
                'Technical / Engineering / Developer / QA / Analyst': /\b(Developer|Engineer|Architect|Technical|QA|Data Scientist|Machine Learning|Programmer|Software|Analyst|IT|Scientist|Researcher|Consultant|Specialist)\b/i, // Broader tech/expert
                 'Marketing / Growth / UA': /\b(Marketing|Growth|User Acquisition|UA|CMO|Brand Manager|PR|Media|Community)\b/i, // Added PR/Community
                // 'Other' is the fallback
            };

            // Stricter check for Investor/VC - needs keywords in company name OR specific titles
            const vcKeywords = /\b(Capital|Ventures|Invest|Fund|Partners|Equity|Group|Advisors|Ventures)\b/i;
            const strictVcTitles = /\b(GP|General Partner|Managing Partner|Venture Partner|Investor|Investment Director|Investment Manager|Investment Associate|Principal)\b/i;


            contacts.forEach(contact => {
                let assignedCategory = null;
                const position = contact.position || '';
                const company = contact.company || '';
                const posLower = position.toLowerCase();
                const compLower = company.toLowerCase();

                // 1. Check CEO / Founder / C-Level First (Highest Priority)
                if (roleMatchers['CEO / Founder / C-Level'].test(position)) {
                    assignedCategory = 'CEO / Founder / C-Level';
                }
                // 2. Check Investor/VC (High Priority, specific checks)
                else if (roleMatchers['Investor / VC / Partner'].test(position)) {
                    if (strictVcTitles.test(position) || vcKeywords.test(company)) {
                         assignedCategory = 'Investor / VC / Partner';
                    }
                    // Let Partner/Associate fall through if not clearly VC
                }
                // 3. Check HR/Talent
                else if (roleMatchers['HR / Recruiter / Talent'].test(position)) {
                    assignedCategory = 'HR / Recruiter / Talent';
                }

                // 4. Check other specific roles
                 if (!assignedCategory) {
                    if (roleMatchers['Business Development / Sales / Partnerships'].test(position)) {
                        assignedCategory = 'Business Development / Sales / Partnerships';
                    } else if (roleMatchers['Marketing / Growth / UA'].test(position)) {
                        assignedCategory = 'Marketing / Growth / UA';
                    } else if (roleMatchers['Product / Design / Producer / Creative'].test(position)) {
                        assignedCategory = 'Product / Design / Producer / Creative';
                     } else if (roleMatchers['Technical / Engineering / Developer / QA / Analyst'].test(position)) {
                        assignedCategory = 'Technical / Engineering / Developer / QA / Analyst';
                    }
                }

                // 5. Check General Leadership (Director/VP/Head/Manager) if not assigned yet
                if (!assignedCategory && roleMatchers['Director / VP / Head Of / Lead'].test(position)) {
                     assignedCategory = 'Director / VP / Head Of / Lead';
                }

                // 6. Assign to the determined category or 'Other'
                if (assignedCategory) {
                    categories[assignedCategory].push(contact);
                } else {
                    categories['Other'].push(contact);
                }
            });

            // Clean up empty categories before returning
             const finalCategories = {};
             for (const category in categories) {
                 if (categories[category].length > 0) {
                     finalCategories[category] = categories[category];
                 }
             }

            return finalCategories; // Return only non-empty categories
        }

        function createNavigation(categorizedContacts) {
            navContainer.innerHTML = ''; // Clear previous nav
            const fragment = document.createDocumentFragment();
            const sortedCategories = Object.keys(categorizedContacts).sort(); // Sort category names alphabetically

            sortedCategories.forEach(category => {
                const tableId = `table-${category.replace(/[^a-zA-Z0-9]/g, '-')}`;
                const link = document.createElement('a');
                link.href = `#${tableId}`; // Link to the table ID
                link.textContent = `${category} (${categorizedContacts[category].length})`;
                 link.onclick = (e) => { // Smooth scroll
                    e.preventDefault();
                    document.getElementById(tableId)?.scrollIntoView({ behavior: 'smooth' });
                 };
                fragment.appendChild(link);
            });
            navContainer.appendChild(fragment);
        }

        function displayContacts(categorizedContacts) {
            container.innerHTML = ''; // Clear previous content
            const sortedCategories = Object.keys(categorizedContacts).sort(); // Sort categories alphabetically for display

            sortedCategories.forEach(category => {
                const contacts = categorizedContacts[category];
                if (contacts.length === 0) return; // Should not happen due to filtering in categorizeContacts, but good check

                const section = document.createElement('div');
                section.className = 'category-section';

                const title = document.createElement('h2');
                title.textContent = `${category} (${contacts.length})`;
                section.appendChild(title);

                const table = document.createElement('table');
                const tableId = `table-${category.replace(/[^a-zA-Z0-9]/g, '-')}`;
                table.id = tableId; // Set ID for navigation anchor
                const thead = table.createTHead();
                const tbody = table.createTBody();
                tbody.id = `tbody-${tableId}`; // ID for tbody manipulation

                const headerRow = thead.insertRow();
                const headers = [
                    { name: 'Имя', key: 'fullName', class: 'col-name' },
                    { name: 'Компания', key: 'company', class: 'col-company' },
                    { name: 'Должность', key: 'position', class: 'col-position' },
                    { name: 'Профиль', key: 'url', class: 'col-profile' }
                ];

                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.textContent = header.name;
                    th.dataset.column = header.key;
                    th.dataset.tableId = tableId;
                    th.classList.add(header.class);
                    th.addEventListener('click', sortTableHandler);
                    headerRow.appendChild(th);
                });

                contacts.forEach(contact => {
                    appendContactRow(tbody, contact, headers); // Use helper function
                });

                section.appendChild(table);
                container.appendChild(section);
            });
            
            // Apply initial filter if search inputs have value
            filterContacts();
        }

        // Helper function to create and append a row (used by displayContacts and potentially filtering)
        function appendContactRow(tbody, contact, headers) {
            const row = tbody.insertRow();
            
            const nameCell = row.insertCell();
            nameCell.textContent = contact.fullName;
            nameCell.classList.add(headers[0].class);
            nameCell.dataset.rawValue = contact.fullName.toLowerCase();

            const companyCell = row.insertCell();
            companyCell.textContent = contact.company;
            companyCell.classList.add(headers[1].class);
            companyCell.dataset.rawValue = contact.company.toLowerCase();

            const positionCell = row.insertCell();
            positionCell.textContent = contact.position;
            positionCell.classList.add(headers[2].class);
            positionCell.dataset.rawValue = contact.position.toLowerCase();

            const profileCell = row.insertCell();
            profileCell.classList.add(headers[3].class);
            profileCell.classList.add('profile-cell'); // Add class for specific styling
            if (contact.url && contact.url.startsWith('http')) {
                const link = document.createElement('a');
                link.href = contact.url;
                link.textContent = "Профиль LinkedIn";
                link.target = "_blank";
                profileCell.appendChild(link);
                if (contact.email) {
                    const emailSpan = document.createElement('span');
                    emailSpan.textContent = `(${contact.email})`;
                    profileCell.appendChild(emailSpan);
                }
            } else {
                profileCell.textContent = 'N/A';
            }
            return row; // Return the created row element
        }

        function filterContacts() {
            const nameValue = nameSearch.value.toLowerCase().trim();
            const companyValue = companySearch.value.toLowerCase().trim();
            const positionValue = positionSearch.value.toLowerCase().trim();
            
            const allRows = document.querySelectorAll('#contacts-container tbody tr');
            
            allRows.forEach(row => {
                const nameCell = row.cells[0];
                const companyCell = row.cells[1];
                const positionCell = row.cells[2];
                
                const nameMatch = !nameValue || nameCell.dataset.rawValue.includes(nameValue);
                const companyMatch = !companyValue || companyCell.dataset.rawValue.includes(companyValue);
                const positionMatch = !positionValue || positionCell.dataset.rawValue.includes(positionValue);
                
                if (nameMatch && companyMatch && positionMatch) {
                    row.classList.remove('hidden-row');
                    
                    // Apply highlighting for visible rows
                    highlightText(nameCell, nameValue);
                    highlightText(companyCell, companyValue);
                    highlightText(positionCell, positionValue);
                } else {
                    row.classList.add('hidden-row');
                }
            });
            
            updateCategoryVisibility();
        }
        
        function highlightText(cell, searchTerm) {
            if (!searchTerm) {
                // Reset to original content if no search term
                cell.innerHTML = cell.textContent;
                return;
            }
            
            const text = cell.textContent;
            const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            cell.innerHTML = text.replace(regex, '<span class="highlight">$1</span>');
        }

        function updateCategoryVisibility() {
            const sections = document.querySelectorAll('.category-section');
            sections.forEach(section => {
                 const table = section.querySelector('table');
                 const tbody = table?.querySelector('tbody');
                 const visibleRows = tbody ? tbody.querySelectorAll('tr:not(.hidden-row)').length : 0;
                 const title = section.querySelector('h2');

                 if (title) {
                     // Update count in title (optional, might be slow for large lists)
                     const originalText = title.textContent.split('(')[0].trim();
                     title.textContent = `${originalText} (${visibleRows})`;

                     // Hide section if no rows are visible due to filtering
                      if (visibleRows === 0) {
                          section.style.display = 'none';
                      } else {
                           section.style.display = '';
                      }
                 }
            });
        }

        let sortStates = {};

        function sortTableHandler(event) {
            const th = event.currentTarget;
            const columnKey = th.dataset.column;
            const tableId = th.dataset.tableId;
            const tbody = document.getElementById(`tbody-${tableId}`);
            if (!tbody) return;

            // Only sort *visible* rows if filtering is active
            const rowsToSort = Array.from(tbody.querySelectorAll('tr:not(.hidden-row)'));
            const hiddenRows = Array.from(tbody.querySelectorAll('tr.hidden-row')); // Keep hidden rows separate

            const columnIndex = Array.from(th.parentNode.children).indexOf(th);
            const sortKey = `${tableId}-${columnKey}`;

            let currentDirection = sortStates[sortKey];
            let newDirection = (currentDirection === 'asc') ? 'desc' : 'asc';
            sortStates[sortKey] = newDirection;

            Array.from(th.parentNode.children).forEach(header => {
                 header.classList.remove('sorted-asc', 'sorted-desc');
             });
            th.classList.add(newDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');

            rowsToSort.sort((a, b) => {
                const cellA = a.cells[columnIndex].textContent.trim().toLowerCase();
                const cellB = b.cells[columnIndex].textContent.trim().toLowerCase();
                let comparison = cellA.localeCompare(cellB); // Use localeCompare for better string sorting
                return newDirection === 'asc' ? comparison : comparison * -1;
            });

            // Re-append sorted visible rows first, then hidden rows
            tbody.innerHTML = '';
            rowsToSort.forEach(row => tbody.appendChild(row));
            hiddenRows.forEach(row => tbody.appendChild(row)); // Append hidden rows at the end
        }
        
        // Analytics functions
        function renderCharts() {
            const analyticsContainer = document.getElementById('analyticsContainer');
            if (!allContactsData || allContactsData.length === 0) {
                analyticsContainer.innerHTML = '<p>Загрузите данные для анализа.</p>';
                return;
            }
            
            // Prepare data for category chart
            renderCategoryChart();
            renderCompanyChart();
        }
        
        function renderCategoryChart() {
            const categorizedContacts = categorizeContacts(allContactsData);
            const categories = Object.keys(categorizedContacts);
            const counts = categories.map(cat => categorizedContacts[cat].length);
            
            const ctx = document.getElementById('categoriesChart').getContext('2d');
            
            // Destroy previous chart if exists
            if (charts.categories) {
                charts.categories.destroy();
            }
            
            charts.categories = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: categories,
                    datasets: [{
                        data: counts,
                        backgroundColor: [
                            '#0077b5', '#00a0dc', '#313335', '#86888a', 
                            '#caccce', '#f5987e', '#dfdbd2', '#6a78d1',
                            '#39c2d7'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'right',
                        },
                        title: {
                            display: true,
                            text: 'Распределение контактов по категориям'
                        }
                    }
                }
            });
        }
        
        function renderCompanyChart() {
            // Get company stats
            const companyStats = {};
            allContactsData.forEach(contact => {
                const company = contact.company || 'N/A';
                if (!companyStats[company]) {
                    companyStats[company] = 0;
                }
                companyStats[company]++;
            });
            
            // Sort by count and get top 10
            const sortedCompanies = Object.entries(companyStats)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            const companyNames = sortedCompanies.map(item => item[0]);
            const companyCounts = sortedCompanies.map(item => item[1]);
            
            const ctx = document.getElementById('companiesChart').getContext('2d');
            
            // Destroy previous chart if exists
            if (charts.companies) {
                charts.companies.destroy();
            }
            
            charts.companies = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: companyNames,
                    datasets: [{
                        label: 'Количество контактов',
                        data: companyCounts,
                        backgroundColor: '#0077b5'
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: 'Топ-10 компаний в вашей сети'
                        }
                    }
                }
            });
        }
        
        // Network visualization
        function renderNetwork() {
            const networkContainer = document.getElementById('networkContainer');
            if (!allContactsData || allContactsData.length === 0) {
                networkContainer.innerHTML = '<p>Загрузите данные для визуализации сети.</p>';
                return;
            }
            
            // Prepare data for network visualization
            const nodes = [];
            const edges = [];
            const nodeMap = new Map();
            
            // Add user node (center)
            nodes.push({
                id: 'you',
                label: 'Вы',
                group: 'user',
                value: 20,
                font: { size: 20 }
            });
            
            // Limit to max 100 contacts for performance
            const maxContacts = Math.min(allContactsData.length, 100);
            const categorizedContacts = categorizeContacts(allContactsData);
            
            // Process each category
            Object.keys(categorizedContacts).forEach(category => {
                const contacts = categorizedContacts[category];
                
                // Process contacts in this category (limit per category)
                const maxPerCategory = Math.ceil(maxContacts / Object.keys(categorizedContacts).length);
                const contactsToShow = contacts.slice(0, maxPerCategory);
                
                contactsToShow.forEach(contact => {
                    const nodeId = `contact-${nodes.length}`;
                    nodeMap.set(contact, nodeId);
                    
                    // Add node for contact
                    nodes.push({
                        id: nodeId,
                        label: contact.fullName,
                        title: `${contact.fullName}<br>${contact.company}<br>${contact.position}`,
                        group: category,
                        value: 10
                    });
                    
                    // Add edge from user to contact
                    edges.push({
                        from: 'you',
                        to: nodeId,
                        value: 1
                    });
                });
            });
            
            // Add company connections (contacts working at same company)
            const companyGroups = {};
            allContactsData.forEach(contact => {
                if (contact.company && contact.company !== 'N/A') {
                    if (!companyGroups[contact.company]) {
                        companyGroups[contact.company] = [];
                    }
                    
                    if (nodeMap.has(contact)) {
                        companyGroups[contact.company].push(nodeMap.get(contact));
                    }
                }
            });
            
            // Connect contacts in same company
            Object.values(companyGroups).forEach(group => {
                if (group.length > 1) {
                    // Connect contacts in same company with edges
                    for (let i = 0; i < group.length - 1; i++) {
                        edges.push({
                            from: group[i],
                            to: group[i + 1],
                            value: 0.5,
                            dashes: true,
                            color: { opacity: 0.3 }
                        });
                    }
                }
            });
            
            // Create visualization
            const data = { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };
            
            const options = {
                nodes: {
                    shape: 'dot',
                    scaling: {
                        min: 10,
                        max: 30
                    }
                },
                edges: {
                    width: 1
                },
                physics: {
                    stabilization: true,
                    barnesHut: {
                        gravitationalConstant: -5000,
                        springConstant: 0.001,
                        springLength: 150
                    }
                },
                groups: {
                    user: { color: '#ff3860', shape: 'star' },
                    'CEO / Founder / C-Level': { color: '#0077b5' },
                    'Investor / VC / Partner': { color: '#00a0dc' },
                    'HR / Recruiter / Talent': { color: '#313335' },
                    'Business Development / Sales / Partnerships': { color: '#86888a' },
                    'Director / VP / Head Of / Lead': { color: '#caccce' },
                    'Product / Design / Producer / Creative': { color: '#f5987e' },
                    'Technical / Engineering / Developer / QA / Analyst': { color: '#dfdbd2' },
                    'Marketing / Growth / UA': { color: '#6a78d1' },
                    'Other': { color: '#39c2d7' }
                }
            };
            
            // Clear any previous network
            networkContainer.innerHTML = '';
            
            // Create network
            network = new vis.Network(networkContainer, data, options);
            
            // Add event listeners (if needed)
            network.on('click', function(params) {
                if (params.nodes.length > 0) {
                    const nodeId = params.nodes[0];
                    // Could add popup with contact details
                }
            });
        }
    </script>

</body>
</html>