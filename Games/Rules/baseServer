const { MCPServer } = require('@anthropic-ai/mcp');
const fs = require('fs');
const path = require('path');

const server = new MCPServer();
const CONFIG_DIR = './configs';
const DATA_DIR = './game_data';

// Ensure directories exist
[CONFIG_DIR, DATA_DIR].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
});

// Системные промпты для разных типов задач
const SYSTEM_PROMPTS = {
  level_design: `
    Ты опытный геймдизайнер, специализирующийся на создании уровней для матч-3 игр.
    
    Твои обязанности:
    1. Анализировать существующие уровни и понимать их структуру, сложность и механики
    2. Создавать новые сбалансированные уровни с интересным геймплеем
    3. Обеспечивать постепенное повышение сложности между уровнями
    4. Разрабатывать уровни с учетом ключевых метрик: средняя продолжительность, % прохождения, использование бустеров
    
    Особенности матч-3 уровней:
    - Размер сетки (обычно от 6x6 до 9x9)
    - Типы ячеек (обычные, блокированные, с особыми эффектами)
    - Цели уровня (набрать очки, собрать определенные элементы, очистить поле)
    - Ограничения (ходы, время, особые условия)
    
    При создании новых уровней соблюдай следующие правила:
    - Каждый уровень должен быть проходимым без использования бустеров
    - Сложность должна соответствовать положению уровня в общей прогрессии
    - Новые механики должны вводиться постепенно
    - Необходимо обеспечить разнообразие целей и механик между уровнями
  `,
  
  economy_analysis: `
    Ты эксперт по игровой экономике с опытом балансировки free-to-play игр.
    
    Твои обязанности:
    1. Анализировать экономические модели и выявлять проблемы
    2. Предлагать изменения для улучшения монетизации и удержания игроков
    3. Оценивать влияние изменений на игровой баланс
    4. Предотвращать эксплойты и экономические дисбалансы
    
    При анализе игровой экономики учитывай:
    - Источники и стоки ресурсов
    - Кривые прогрессии игроков
    - Точки монетизации
    - Показатели удержания и конверсии
    
    Твои рекомендации должны быть конкретными, с числовыми значениями и оценкой ожидаемого эффекта.
  `,
  
  narrative_design: `
    Ты креативный сценарист с опытом создания историй и диалогов для казуальных игр.
    
    Твои обязанности:
    1. Создавать увлекательные сюжетные линии и квесты
    2. Разрабатывать запоминающихся персонажей с уникальными характерами
    3. Писать диалоги, соответствующие тону и стилю игры
    4. Интегрировать сюжетные элементы с игровыми механиками
    
    Особенности повествования в казуальных играх:
    - Краткие, но эмоциональные сцены
    - Понятные мотивации персонажей
    - Юмор и позитивный настрой
    - Интеграция с механиками игры
    
    Твои тексты должны быть доступными для широкой аудитории, поддерживать интерес к игре и мотивировать игроков продолжать.
  `,
  
  game_analysis: `
    Ты аналитик игровых данных, специализирующийся на анализе метрик и улучшении геймплея.
    
    Твои обязанности:
    1. Анализировать игровые данные и выявлять тренды и аномалии
    2. Оценивать баланс игровых механик и прогрессии
    3. Предлагать конкретные изменения для улучшения показателей
    4. Прогнозировать влияние изменений на ключевые метрики
    
    При анализе игровых данных обращай внимание на:
    - Уровни с аномально высоким отсевом игроков
    - Дисбаланс в использовании игровых механик
    - Проблемы с кривой сложности
    - Возможности для улучшения монетизации
    
    Результаты твоего анализа должны быть основаны на данных, с конкретными рекомендациями.
  `,
  
  retro_style: `
    Ты эксперт по стилизации игр под ретро-эстетику, особенно в стиле игр Spectrum.
    
    Твои обязанности:
    1. Создавать и оценивать визуальный стиль игровых элементов
    2. Предлагать цветовые схемы и графические приемы в стиле ретро
    3. Адаптировать современные механики под ограничения ретро-стиля
    4. Рекомендовать звуковое и музыкальное оформление в ретро-стиле
    
    Ключевые элементы ретро-стиля Spectrum:
    - Ограниченная цветовая палитра (обычно до 16 цветов)
    - Пиксельная графика с четкими границами
    - Минималистичный дизайн с акцентом на читаемость
    - Характерные звуковые эффекты и музыка
    
    Твои рекомендации должны сохранять аутентичность ретро-стиля, при этом обеспечивая удобство для современных игроков.
  `
};

// Инструмент для получения списка доступных конфигов
server.addTool({
  name: 'list_configs',
  description: 'Получить список доступных конфигурационных файлов',
  async handler() {
    const files = fs.readdirSync(CONFIG_DIR)
      .filter(file => file.endsWith('.json'));
    return { files };
  }
});

// Инструмент для чтения конфига
server.addTool({
  name: 'read_config',
  description: 'Получить содержимое конфигурационного файла',
  parameters: {
    filename: { type: 'string', description: 'Имя файла' }
  },
  async handler({ filename }) {
    const filePath = path.join(CONFIG_DIR, filename);
    if (!fs.existsSync(filePath)) {
      return { error: 'Файл не найден' };
    }
    const content = JSON.parse(fs.readFileSync(filePath, 'utf8'));
    return { content };
  }
});

// Инструмент для сохранения конфига
server.addTool({
  name: 'save_config',
  description: 'Сохранить конфигурационный файл',
  parameters: {
    filename: { type: 'string', description: 'Имя файла' },
    content: { type: 'object', description: 'Содержимое файла' }
  },
  async handler({ filename, content }) {
    const filePath = path.join(CONFIG_DIR, filename);
    fs.writeFileSync(filePath, JSON.stringify(content, null, 2));
    return { success: true, message: `Файл ${filename} успешно сохранен` };
  }
});

// Инструмент для генерации уровня
server.addTool({
  name: 'generate_level',
  description: 'Создать новый уровень для матч-3 игры',
  parameters: {
    level_number: { type: 'number', description: 'Номер уровня в последовательности' },
    difficulty: { type: 'string', description: 'Целевая сложность (easy, medium, hard)' },
    special_mechanics: { 
      type: 'array', 
      description: 'Особые механики для использования',
      required: false
    },
    reference_level: { 
      type: 'string', 
      description: 'Имя файла с референсным уровнем',
      required: false
    }
  },
  async handler({ level_number, difficulty, special_mechanics, reference_level }) {
    // Собираем необходимый контекст
    let contextData = {
      level_number,
      difficulty,
      special_mechanics: special_mechanics || []
    };
    
    // Если указан референсный уровень, добавляем его в контекст
    if (reference_level) {
      const refLevelPath = path.join(CONFIG_DIR, reference_level);
      if (fs.existsSync(refLevelPath)) {
        contextData.reference = JSON.parse(fs.readFileSync(refLevelPath, 'utf8'));
      }
    }
    
    // Читаем общие правила уровней
    const rulesPath = path.join(CONFIG_DIR, 'level_rules.json');
    if (fs.existsSync(rulesPath)) {
      contextData.rules = JSON.parse(fs.readFileSync(rulesPath, 'utf8'));
    }
    
    // Формируем запрос к LLM с соответствующим системным промптом
    const response = await requestLLM(
      SYSTEM_PROMPTS.level_design,
      `Создай новый уровень для матч-3 игры согласно следующим параметрам:
       - Номер уровня: ${level_number}
       - Сложность: ${difficulty}
       - Особые механики: ${special_mechanics ? special_mechanics.join(', ') : 'нет'}
       
       Используй структуру существующих уровней и соблюдай установленные правила дизайна.
       Верни результат в JSON формате.`,
      contextData
    );
    
    // Генерируем имя файла для нового уровня
    const newLevelFilename = `level_${level_number}_${difficulty}_${Date.now()}.json`;
    const newLevelPath = path.join(CONFIG_DIR, newLevelFilename);
    
    // Сохраняем сгенерированный уровень
    fs.writeFileSync(newLevelPath, JSON.stringify(response.level, null, 2));
    
    return {
      filename: newLevelFilename,
      level: response.level,
      design_notes: response.design_notes
    };
  }
});

// Инструмент для загрузки игровых данных
server.addTool({
  name: 'upload_game_data',
  description: 'Загрузить игровые данные для анализа',
  parameters: {
    data_type: { type: 'string', description: 'Тип данных (metrics, levels, economy, player_behavior)' },
    content: { type: 'object', description: 'Содержимое данных' },
    filename: { 
      type: 'string', 
      description: 'Имя файла для сохранения данных',
      required: false
    }
  },
  async handler({ data_type, content, filename }) {
    // Генерируем имя файла, если не указано
    const actualFilename = filename || `${data_type}_${Date.now()}.json`;
    const filePath = path.join(DATA_DIR, actualFilename);
    
    // Сохраняем данные
    fs.writeFileSync(filePath, JSON.stringify(content, null, 2));
    
    return { 
      success: true, 
      message: `Данные успешно загружены как ${actualFilename}`,
      filename: actualFilename
    };
  }
});

// Инструмент для получения списка загруженных данных
server.addTool({
  name: 'list_game_data',
  description: 'Получить список загруженных игровых данных',
  parameters: {
    data_type: { 
      type: 'string', 
      description: 'Тип данных для фильтрации (metrics, levels, economy, player_behavior)',
      required: false
    }
  },
  async handler({ data_type }) {
    const files = fs.readdirSync(DATA_DIR)
      .filter(file => file.endsWith('.json'))
      .filter(file => !data_type || file.startsWith(data_type));
    
    return { files };
  }
});

// Инструмент для чтения игровых данных
server.addTool({
  name: 'read_game_data',
  description: 'Получить содержимое файла с игровыми данными',
  parameters: {
    filename: { type: 'string', description: 'Имя файла' }
  },
  async handler({ filename }) {
    const filePath = path.join(DATA_DIR, filename);
    if (!fs.existsSync(filePath)) {
      return { error: 'Файл не найден' };
    }
    
    const content = JSON.parse(fs.readFileSync(filePath, 'utf8'));
    return { content };
  }
});

// Инструмент для анализа игровых данных
server.addTool({
  name: 'analyze_game_data',
  description: 'Анализировать игровые данные и получить рекомендации',
  parameters: {
    filename: { type: 'string', description: 'Имя файла с данными' },
    analysis_type: { 
      type: 'string', 
      description: 'Тип анализа (level_balance, economy, player_retention, difficulty_curve)',
      required: false 
    }
  },
  async handler({ filename, analysis_type }) {
    const filePath = path.join(DATA_DIR, filename);
    if (!fs.existsSync(filePath)) {
      return { error: 'Файл не найден' };
    }
    
    // Загружаем данные для анализа
    const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
    
    // Определяем тип анализа на основе имени файла, если не указан
    const dataType = analysis_type || (
      filename.startsWith('metrics') ? 'game_analysis' :
      filename.startsWith('economy') ? 'economy_analysis' :
      filename.startsWith('levels') ? 'level_design' :
      'game_analysis'
    );
    
    // Выбираем соответствующий системный промпт
    const systemPrompt = SYSTEM_PROMPTS[dataType] || SYSTEM_PROMPTS.game_analysis;
    
    // Формируем запрос к LLM
    const response = await requestLLM(
      systemPrompt,
      `Проанализируй следующие игровые данные и предложи конкретные рекомендации для улучшения:
       
       Тип данных: ${filename}
       ${analysis_type ? `Требуемый тип анализа: ${analysis_type}` : ''}
       
       Предоставь структурированный анализ с выделением ключевых проблем и конкретными рекомендациями.`,
      { data }
    );
    
    // Сохраняем результаты анализа
    const analysisFilename = `analysis_${filename}`;
    const analysisPath = path.join(DATA_DIR, analysisFilename);
    fs.writeFileSync(analysisPath, JSON.stringify(response, null, 2));
    
    return {
      analysis: response,
      filename: analysisFilename
    };
  }
});

// Инструмент для улучшения существующего уровня
server.addTool({
  name: 'improve_level',
  description: 'Улучшить существующий уровень на основе данных анализа',
  parameters: {
    level_filename: { type: 'string', description: 'Имя файла с уровнем' },
    analysis_filename: { 
      type: 'string', 
      description: 'Имя файла с результатами анализа',
      required: false
    },
    improvement_focus: { 
      type: 'string', 
      description: 'Фокус улучшений (difficulty, variety, engagement, retention)',
      required: false
    }
  },
  async handler({ level_filename, analysis_filename, improvement_focus }) {
    // Загружаем данные уровня
    const levelPath = path.join(CONFIG_DIR, level_filename);
    if (!fs.existsSync(levelPath)) {
      return { error: 'Файл уровня не найден' };
    }
    const levelData = JSON.parse(fs.readFileSync(levelPath, 'utf8'));
    
    // Загружаем данные анализа, если указаны
    let analysisData = {};
    if (analysis_filename) {
      const analysisPath = path.join(DATA_DIR, analysis_filename);
      if (fs.existsSync(analysisPath)) {
        analysisData = JSON.parse(fs.readFileSync(analysisPath, 'utf8'));
      }
    }
    
    // Формируем запрос к LLM
    const response = await requestLLM(
      SYSTEM_PROMPTS.level_design,
      `Улучши существующий уровень на основе следующей информации:
       
       ${improvement_focus ? `Фокус улучшений: ${improvement_focus}` : 'Произведи общие улучшения баланса и интереса'}
       
       Верни улучшенную версию уровня в JSON формате.`,
      { 
        level: levelData,
        analysis: analysisData,
        focus: improvement_focus
      }
    );
    
    // Генерируем имя файла для улучшенного уровня
    const improvedFilename = `improved_${level_filename}`;
    const improvedPath = path.join(CONFIG_DIR, improvedFilename);
    
    // Сохраняем улучшенный уровень
    fs.writeFileSync(improvedPath, JSON.stringify(response.level, null, 2));
    
    return {
      filename: improvedFilename,
      level: response.level,
      improvement_notes: response.improvement_notes
    };
  }
});

// Инструмент для генерации ретро-стилизации
server.addTool({
  name: 'generate_retro_style',
  description: 'Создать рекомендации по ретро-стилизации в духе игр Spectrum',
  parameters: {
    game_element: { type: 'string', description: 'Элемент игры (graphics, ui, sound, gameplay)' },
    description: { type: 'string', description: 'Описание элемента для стилизации' }
  },
  async handler({ game_element, description }) {
    // Формируем запрос к LLM
    const response = await requestLLM(
      SYSTEM_PROMPTS.retro_style,
      `Создай рекомендации по ретро-стилизации в духе игр Spectrum для следующего элемента:
       
       Тип элемента: ${game_element}
       Описание: ${description}
       
       Предоставь конкретные рекомендации по цветовой палитре, визуальному стилю, звуковому оформлению
       и другим аспектам, сохраняя аутентичность ретро-стиля Spectrum.`,
      { element_type: game_element, description }
    );
    
    // Генерируем имя файла для рекомендаций
    const styleFilename = `retro_style_${game_element}_${Date.now()}.json`;
    const stylePath = path.join(DATA_DIR, styleFilename);
    
    // Сохраняем рекомендации
    fs.writeFileSync(stylePath, JSON.stringify(response, null, 2));
    
    return {
      filename: styleFilename,
      recommendations: response
    };
  }
});

// Функция для запроса к LLM (упрощенная версия)
async function requestLLM(systemPrompt, userPrompt, contextData) {
  // В реальной реализации здесь был бы код для обращения к Claude или GPT
  // через API с использованием системного промпта
  console.log('Системный промпт:', systemPrompt);
  console.log('Запрос:', userPrompt);
  console.log('Контекст:', JSON.stringify(contextData, null, 2));
  
  // Имитация ответа LLM для разных типов запросов
  
  // Если это анализ данных
  if (userPrompt.includes('Проанализируй')) {
    return {
      issues: [
        { severity: "high", description: "Высокий отток игроков на уровне 5", recommendation: "Снизить сложность, увеличить награду" },
        { severity: "medium", description: "Низкая вовлеченность в событиях", recommendation: "Улучшить визуальное оформление, добавить уникальные награды" }
      ],
      recommendations: {
        short_term: ["Пересмотреть баланс сложности уровней 5-8", "Улучшить туториал"],
        long_term: ["Добавить новые механики для удержания", "Реструктурировать экономическую модель"]
      },
      metrics_prediction: {
        retention: "+5% при внедрении рекомендаций",
        monetization: "+8% ARPU при балансировке экономики"
      }
    };
  }
  
  // Если это улучшение уровня
  if (userPrompt.includes('Улучши существующий уровень')) {
    return {
      level: {
        id: contextData.level.id,
        difficulty: contextData.level.difficulty,
        grid_size: contextData.level.grid_size,
        moves_limit: contextData.level.moves_limit + 5, // Увеличиваем лимит ходов
        goals: contextData.level.goals,
        special_cells: [
          ...contextData.level.special_cells,
          { x: 4, y: 4, type: "bonus" } // Добавляем бонусную ячейку
        ],
        special_mechanics: contextData.level.special_mechanics
      },
      improvement_notes: "Увеличен лимит ходов для снижения сложности, добавлена бонусная ячейка для повышения вариативности геймплея"
    };
  }
  
  // Если это ретро-стилизация
  if (userPrompt.includes('Создай рекомендации по ретро-стилизации')) {
    return {
      color_palette: {
        primary: ["#0000FF", "#FF0000", "#FFFF00"], // Базовые цвета Spectrum
        background: "#000000",
        ui: ["#FFFFFF", "#00FF00"]
      },
      visual_style: {
        resolution: "256x192", // Стандартное разрешение ZX Spectrum
        pixel_art: "Четкие границы, минимум градиентов, ограниченная анимация",
        character_design: "Узнаваемые силуэты, минимум деталей, яркие акценты"
      },
      sound: {
        effects: "Короткие, резкие звуки с простой огибающей",
        music: "Простые, запоминающиеся мелодии с ограниченной полифонией",
        recommendations: "Использовать AY-3-8910 эмуляцию для аутентичности"
      },
      implementation_tips: [
        "Ограничить палитру до 16 цветов максимум",
        "Использовать пиксельную сетку 8x8 для элементов",
        "Избегать сглаживания и альфа-прозрачности",
        "Применять характерный 'цветовой дизеринг' для расширения визуальной палитры"
      ]
    };
  }
  
  // Для генерации уровня (по умолчанию)
  return {
    level: {
      id: `level_${contextData.level_number || 1}`,
      difficulty: contextData.difficulty || "medium",
      grid_size: { width: 8, height: 8 },
      moves_limit: 30,
      goals: [
        { type: "collect", item: "red_gem", count: 15 },
        { type: "collect", item: "blue_gem", count: 15 }
      ],
      special_cells: [
        { x: 2, y: 3, type: "blocker" },
        { x: 5, y: 6, type: "blocker" }
      ],
      special_mechanics: contextData.special_mechanics || []
    },
    design_notes: "Этот уровень знакомит игрока с блокированными ячейками, требуя стратегического подхода к сбору гемов."
  };
}

// Запуск сервера
server.start(3000).then(() => {
  console.log('MCP сервер запущен на порту 3000');
  console.log('Доступные операции:');
  console.log('- Загрузка игровых данных');
  console.log('- Анализ данных и получение рекомендаций');
  console.log('- Генерация и улучшение уровней');
  console.log('- Создание ретро-стилизации в духе Spectrum');
  console.log('Директории:');
  console.log(`- Конфигурация: ${path.resolve(CONFIG_DIR)}`);
  console.log(`- Игровые данные: ${path.resolve(DATA_DIR)}`);
});